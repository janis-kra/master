% !TEX root = ../thesis.tex
%
\chapter{Implementation}
\label{ch:implementation}

This chapter describes details about the implementation and configuration of the passive user feedback system.
Appendix \cref{ch:appendix:source} contains the source code of the services and applications that were created over the course of this thesis; these are also available via GitHub\footnote{\url{https://github.com/janis-kra/master-impl}}\todo{link to "final" tag when done}.

\section{Service Orchestration}
\label{sec:implementation:orchestration}

All services run in their own Docker containers in order to facilitate distribution of the system.
Orchestration of the containers is done via \emph{Docker Compose} (short \emph{Compose}).
Compose is nice because reasons\todo{insert blurb about Compose}.

Docker allows to assign each container a custom network which allows for virtualization of distinct and separated networks even though the containers are all on the same server.
This is done via the \texttt{networks} setting for all container definitions, in this case setting the network to \texttt{esnet}.
The \texttt{esnet} network is a default bridge network, thus ...

\section{Client Application}
\label{sec:implementation:client}

\subsection{Technical Problems with Click Tracking}

When tracking clicks in a web application, the technical idiosyncrasies of reliably sending data via \ac{XHR} requests using JavaScript can become problematic.
For various reasons, which are discussed below, there are no valid alternatives to doing asynchronous \ac{XHR} requests for click tracking for this use case though.

The gist of the problem is that when a user clicks a link in a web application, this normally introduces a redirect to a new page, therefore potentially aborting the asynchronous \ac{XHR} request\cite{Kohavi2010}.
This problem could be solved by doing a synchronous request instead of an asynchronous one, but this is not a desirable solution for two reasons.
First, the whole web application blocks for the duration of the request; if the user's internet connection is slow -- e.g .when accessing the application on a mobile phone -- or the logging server is experiencing heavy load, this can introduce a noticeable and annoying delay.
These delays can be a reason to make the user abandon the application altogether\cite{Kohavi2010,Dmitriev2017}.

In order to mitigate these problems, the Navigator \ac{API} of modern browsers was extended with the \texttt{sendBeacon}\footnote{\url{https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon}} method, but this cannot be used for this use case for two reasons.
The concept of the \texttt{sendBeacon} method is that it can be used to asynchronously send a small amount of data to a server prior to the user leaving the page, in a reliable way.
However, this is not implemented yet in all modern browsers\footnote{\url{https://caniuse.com/\#feat=beacon}}, especially Internet Explorer and the desktop and mobile Safari browsers.
Also, when posting data to Event Store using its \ac{HTTP} \ac{API}, the \texttt{ES-EventId} header has to be attached to the request with a unique id.
Attaching custom headers via the \texttt{sendBeacon} method is not supported though.

For the reasons discussed above, a standard asynchronous \ac{XHR} is the best alternative.
This would introduce click data being lost when the request is dropped, but as the Mattermost chat application used as the client here is a single-page application, this is not a problem.

\section{Storage Configuration}
\label{sec:implementation:storage}

The storage layer of the passive user feedback system is realized via the event store reference implementation (\cref{sec:classifications:storage}).
An officially maintained Docker image\footnote{\url{https://hub.docker.com/r/eventstore/eventstore/}} is used as the starting point and requires little additional configuration.
The relevant lines from the \texttt{docker-compose.yml} file are listed in \todo{cref to code listing here}.

% code listing: docker-compose.yml#eventstore

This spins up a EventStore container with mostly default settings, which could be further configured via ?.
\todo{explain what could be configured+what the default settings are}

Aside from specifying the image base and its name, these settings make the EventStore's TCP and HTTP interfaces available via ports 1113 and 2113.
The container can be accessed by other containers via its name, \texttt{eventstore}.
Thus, the client application can post events via HTTP to \url{http://evenstore:2113}, while the bridge to the aggregation service (cf. \cref{sec:implementation:bridge}) listens to new events via the TCP address \url{tcp://eventstore:1113}.

\section{Storage-Aggregation Bridge}
\label{sec:implementation:bridge}

Because Elasticsearch does not have dedicated support for importing data from an event store, an additional service had to be implemented which serves as a bridge between the two services.

\section{Aggregation Service}
\label{sec:implementation:aggregation}

\section{Analysis Application}
\label{sec:implementation:analysis}

